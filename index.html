<!DOCTYPE html>
<html lang="uz">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rangli Geometry Dash</title>
<link rel="stylesheet" href="./style.css">
<link rel="stylesheet" href="./script.js">
<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body {
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  canvas {
    border: 4px solid #0ff;
    border-radius: 10px;
    
    
  }
  
  #score {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: bold;
    color: #0ff;
  }
  #restartMsg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    color: #f00;
    display: none;
    user-select: none;
    text-align: center;
  }
</style>
</head>
<body>

<div id="score">Ball: 0</div>
<div id="restartMsg">Oâ€˜yin tugadi! <br> Space bilan qayta boshlang</div>
<canvas id="game" width="600" height="300"></canvas>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const restartMsg = document.getElementById('restartMsg');

  const GRAVITY = 0.6;
  const JUMP_STRENGTH = -12;

  let player = {
    x: 50,
    y: 0,
    width: 30,
    height: 30,
    dy: 0,
    grounded: false
  };

  let obstacles = [];
  let obstacleTimer = 0;
  let obstacleInterval = 90; // frames between obstacles

  let score = 0;
  let gameOver = false;

  let colorProgress = 0; // 0 to 1 for background transition

  function lerpColor(a, b, t) {
    const ar = (a >> 16) & 0xff,
          ag = (a >> 8) & 0xff,
          ab = a & 0xff;

    const br = (b >> 16) & 0xff,
          bg = (b >> 8) & 0xff,
          bb = b & 0xff;

    const rr = Math.round(ar + (br - ar) * t);
    const rg = Math.round(ag + (bg - ag) * t);
    const rb = Math.round(ab + (bb - ab) * t);

    return `rgb(${rr}, ${rg}, ${rb})`;
  }

  function resetGame() {
    player.y = 0;
    player.dy = 0;
    obstacles = [];
    obstacleTimer = 0;
    score = 0;
    gameOver = false;
    restartMsg.style.display = 'none';
    scoreEl.textContent = 'Ball: 0';
    colorProgress = 0;
  }

  function createObstacle() {
    const height = 40 + Math.random() * 60;
    obstacles.push({
      x: canvas.width,
      y: canvas.height - height,
      width: 20,
      height: height
    });
  }

  function update() {
    if (gameOver) return;

    player.dy += GRAVITY;
    player.y += player.dy;

    if (player.y + player.height > canvas.height) {
      player.y = canvas.height - player.height;
      player.dy = 0;
      player.grounded = true;
    } else {
      player.grounded = false;
    }

    obstacleTimer++;
    if (obstacleTimer > obstacleInterval) {
      createObstacle();
      obstacleTimer = 0;
    }

    obstacles.forEach(ob => {
      ob.x -= 5;
    });

    obstacles = obstacles.filter(ob => ob.x + ob.width > 0);

    for (let ob of obstacles) {
      if (
        player.x < ob.x + ob.width &&
        player.x + player.width > ob.x &&
        player.y < ob.y + ob.height &&
        player.y + player.height > ob.y
      ) {
        gameOver = true;
        restartMsg.style.display = 'block';
      }
    }

    // Update score
    score++;
    scoreEl.textContent = 'Ball: ' + score;

    // Update background & player color gradient progress
    colorProgress = Math.min(1, score / 1000); // Slowly transition

    draw();
    requestAnimationFrame(update);
  }

  function draw() {
    // Background: from blue (#0000ff) to red (#ff0000)
    const bgColor = lerpColor(0x0000ff, 0xff0000, colorProgress);
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Player color: from red (#ff0000) to blue (#0000ff)
    const playerColor = lerpColor(0xff0000, 0x0000ff, colorProgress);
    ctx.fillStyle = playerColor;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Obstacles (remain red)
    ctx.fillStyle = '#f00';
    obstacles.forEach(ob => {
      ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
    });
  }

  // Controls
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      if (gameOver) {
        resetGame();
        update();
      } else if (player.grounded) {
        player.dy = JUMP_STRENGTH;
        player.grounded = false;
      }
    }
  });

  resetGame();
  update();
</script>

</body>
</html>
